# Godocs

**Godocs** is a package that helps in the process of **building Godot documentation**.

## How to Use

To use this package, you'll need the `XML` files generated by **Godot's** `doctool` utility, using a **command** similar to the **below**:

``` sh
godot --headless --doctool <out-dir> --no-docbase --gdscript-docs res://<in-dir>
```

With these files, `godocs` can be used to **parse** them into `.rst` documentation markdown like the following:

``` sh
godocs <input-dir> <output-dir>
```

### Commands

Godocs provides a CLI with commands for generating documentation. Here's a quick list:

``` sh
godocs --[h]elp
godocs --[p]lugin

godocs construct --[h]elp
godocs construct {constructor}
godocs construct jinja --[h]elp
godocs construct jinja --[t]ranslator --[m]odel --[T]emplates --[F]ilters --[B]uilders <in> <out>
```

## Installing dependencies

It's **recommended** to be **inside a virtual environment** before **installing the project dependencies**, as to **not clutter your global dependencies**.

To **create a virtual environment in the project folder** using Python's built-in `venv` module, run the following command:

``` sh
python -m venv .venv
```

This will create a **venv** inside the `.venv` folder, which can then be activated executing:

``` sh
.venv/Scripts/activate
```

Now, the installations can be made with either command:

``` sh
# For production only dependencies:
pip install .

# For development dependencies:
pip install .[dev]

# For peer dependencies:
pip install .[peer]
```

The **dependencies** installed are **listed** in the `pyproject.toml` under the `[project.dependencies]` field - for general **required dependencies** - and the `[project.optional-dependencies.dev]` field - for **development dependencies** (which include test and build stuff).

**Peer dependencies** are can be **found** under the `[project.optional-dependencies.peer]` field. `Jinja2` is considered a **peer dependency** for this library as you can create **your own** `Constructors` that **don't** necessarily **need that package**, making its installation **unecessary** in those cases.

If you want to use the **default** `Constructor` (most of the cases, probably), you can just **install** the **peer dependencies** with the **command** shown **above**.

## Building

### For development

In a **dev context**, it's easier to **build** the project with the **editable option**, so **changes are automatically reflected in the current environment**.

To do so, run the following command:

``` sh
pip install --editable .
```

### For production

To **build the project** for production, the `build` **dependency is needed**, which is specified in the **dev dependencies** from `pyproject.toml`.

With that **dependency installed** (through the **installation of the dev dependencies**, or its manual installation), the following command can be used:

``` sh
python -m build .
```

This will use the `setuptools` **build backend** in an **isolated temporary environment** to **create the distributables**.

When executed, **there should be** a `dist` folder with a `.tar.gz` archive and a `.whl` build.

## Deploying
To deploy this package, use the following command:

``` sh
python -m twine upload dist/*
```

## Extending
Godocs strives to be **open for configurations and extensions** from users, that's why a **plugin system** is implemented.

Currently, users can add to the application both through script plugins and plugin packages by extending the `Plugin` class. Users can add **custom constructors** as well as **custom CLI commands** to receive the configurations for those constructors, or any other modifications they want.

Scripts that define plugins should **expose** a `Plugin` class, that implements the base `godocs.plugin.Plugin` with its main `register` method defining what happens when this plugin is used.

Down below is a snippet showing an example of a **custom command plugin**, that adds a **constructor option** to the CLI, and, when chosen prints `"[Godocs Construct Custom]"` and the args `Namespace` received from argsparse:

``` python
from argparse import Namespace
from godocs.plugin import Plugin as BasePlugin
from godocs.cli import AppCommand


class Plugin(BasePlugin):

    def exec(self, args: Namespace):
        print("[Godocs Construct Custom]")
        print(args)

    def register(self, app: AppCommand):
        construct = app.commands["construct"]

        construct_subparsers = construct.subparsers

        if construct_subparsers is None:
            raise

        custom_parser = construct_subparsers.add_parser(
            "custom", help="Construct docs using a custom constructor.", parents=[construct.subparsers_parent])

        custom_parser.set_defaults(func=self.exec)

```

In order to **apply this plugin** to the **CLI**, the `-p` or `--plugin` **option** can be passed with the **path to this script** in the `godocs` program.

In order to make plugins more easily shareable, plugin packages are also supported by using entry points. Here's an example of how the `godocs-jinja` plugin exposes itself as a plugin so `godocs` can find and register it:

``` python
# pyproject.toml
[project.entry-points."godocs.plugins"]
jinja = "godocs_jinja.main:JinjaPlugin"
```
